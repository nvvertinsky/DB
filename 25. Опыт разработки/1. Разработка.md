# Разработка

### Модули:

Состав подсистемы:
  - Пакет контроллер. WI.
    - Предоставляем внешнему сервису только определенные методы.
  - Пакет сервис. API. 
    - Если для двух сервисов нужен один и тот же код, то создаем еще один пакет API.
    - Если для одного API нужен один и тот же код, то делаем метод внутри API private. 
  - Пакет для DML, SELECT. DAO.
  - Пакет TAPI. Валидация. Могут вызывать методы API своей подсистемы.
  - Объекты - модели. 

### Иерархия:
  - Принципы SOLID, DRY, YAGNI
    - Шаблоны проектировния, шаблоны GRASP
      - Алгоритмы

### Опыт: 
  - Делаем описание каждого объекта
  - Проверять входящие параметры
  - В функцию передавать параметры скалярные/объекты, чтобы использовать функцию в SQL
  - При создании новой схемы или таблицы - сделать джоб сбора статистики
  - Если нет возможности формировать xls файл в приложении, то можно формировать csv
  - Не использовать большие запросы прямо в коде самих процедур. Разбивать на более мелкие модули.
  - Если какая то функция возвращает null, то обрабатывай это
  - Делать валидацию на сервере. Лучше в TAPI. Если будет время, тогда еще на клиенте
  - Печатные формы вызывать через docform. Ограничения по печати писать там.
  - Любые манипуляции с данными делаем через процедуры/функции обертки в пакетах.
    - Если допустим добавится обязательный столбец, то достаточно будет добавить его в этой процедуре/функции.
  - Валидацию строки делать в TAPI. Так как DML операции могут выполнять из разных мест.
  - При сохранении в базу даты, всегда пишем маску 'dd.mm.yyyy hh24:mi:ss'. Даже если сама дата без минут или секунд.
  - Дата не должна быть больше маски.
  - Параллельная разработка возможна только если будем править разные объекты
  - При разработке большого проекта невозможно написать хороший код с первого раз. Требования постоянно меняются, код меняется. Когда основная разработка будет закончена, а требования сформированы, то можно сделать рефакторинг.
  - Не обязательно знать досконально технологию. Достаточно знать что есть такая технология, которая решает определённую проблему. А за деталями обращаться к справочникам.
  - Языки программирования, low-code платформы это всего лишь инструменты. Которые нужно применять в определенных ситуациях
  - По сути код нужно писать так, чтобы это потом легко было читать/менять. То есть занимало как можно меньше времени на чтение/изменение.
  - Иногда вместо концентрации на коде, мы концентрируемся на оптимизации. Преждевременная оптимизация это зло.
  - В интерфейсе не скрываем кнопки от пользователя. Лучше при нажатии выдавать ошибку.
  - resmon.exe утилита для просмотра занятых портов.
  - Код должен быть покрыт юнит-тестами
  - Делать пакеты с именованными exception
  - APEX процессы умеют обрабатывать ошибки пакета err
  - Цикл разработки: 
    - Делаем сначала хреново
	- Затем тестируем и исправляем ошибки. Делаем чтобы работало
	- Делаем рефакторинг. Делаем более маштабируемый и изменяемый код
  - За каждый фокусом должно быть расслабление. Никаких соц сетей.
  - Не использовать представления. Использовать функции возвращающие объект.
    - Сложно дебажить
    - Нет обработки исключений
  - Обязательно делать проверку в ядре функционала. Например TAPI. 
  - Мы должны отвечать на HTTP запросы быстро. Если нужно вызвать процедуру, которая долго выполняется, то лучше добавить сообщение в очередь.
  - Императивный код читается проще, чем большие SQL запросы.
  - При создании новой таблицы или схемы делать джоб собирающий статистику

### Алгоритмы

Зачем нужны:
  - Проверяют не то как ты решаешь алгоритмы. Проверяют твои навыки решения неизвестных проблем.
  - Развитие интуиции при решении базовых задач
  - Навыки поиска решения проблем в условиях неопределенности
  - Умение не сдаваться сразу

Как проходить собес:
  - Попросить примеры
  - Уточнять ограничения
  - Спрашивать что не понятно
  - Набросить псевдокод
  - Сделать хреновое решение brutforce
  - Попросить подсказку