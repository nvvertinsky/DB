### Список:
  - Index Unique Scan
  - Index skip scan
  - Index Range scan
  - Index Full Scan
  - Index Fast Full Scan


### Index Fast Full Scan
Особенности: Значительно отличается от полного сканирования индекса. см. ниже.

Условия: В запросе указаны все проиндексиронные столбцы и сортировка не нужна.

Как работает:
Читаем листовые блоки параллельно.

Пример: 
````
select empno, empname from emp;
````

### Index Full Scan
Особенности: 
  - Читаются все листовые блоки индекса.
  - Данные извлекаются в отсортированном виде
  - За одну операцию ввода вывода читаем один блок

Условия:
  1. В запросе указаны все проиндексиронные столбцы
  2. В запросе указан order by
  3. Порядок использования колонок в order by должен совпадать с порядком колонок в индексе

Как работает:
  1. Сканирование начинается с корневого блока и перемещается по ветвям вниз к самому первому листовому блоку. 
  2. После прочтения первого листового блока все остальные блоки читаются по порядку.


Пример 1:
````
select empno, ename from emp order by empno;
````

Пример 2. Oracle может выполнять полное сканирование индекса вместо таблицы, только если у вас есть ограничение not null на столбец:
````
select indexed_col from table;
````


### Index Range scan
Особенности: 
  - Индексное сканирование по диапазону. Применяется при поиске по диапазону значений или при равенстве из неуникальных индексов.
  - Данные извлекаются в сортированном порядке. Это исключает доп сортировку при операциях group by/order by по ключу.

Условия:
  1. В условиях запроса используется один или несколько лидирующих столбцов индекса.
  2. Индекс может быть уникальным или обычным.

Как работает:
  1. Сканирование начинается с корневого блока и перемещается по ветвям вниз к блоку, где находится стартовое значение диапазона. 
  2. Затем происходит сканирование всех значений после этого стартового значения, в соответствии с условием. 
  3. Если надо, алгоритм переходит с листа на лист, не поднимаясь к узлу. Возможны любые направления прохода по индексу asc/desc.(например если в запросе order by desc, то проход по листьям будет в обратном направлении)
  
Пример 1. Будет range scan. Потому что индекс emp_department_ix не уникальный. И в листах у него не уникальные значения, а значит, добравшись до искомого листа, придется проходить по диапазону равному = 10. Таких элементов будет больше чем “1”. Потому и применяется range scan.
````
create index emp_department_ix on employees (department_id);
select * from employees t where t.department_id = 10;
````

Пример 2. В плане фигурирует range scan по unique index - emp_emp_id_pk. Казалось бы, индекс уникальный, почему не unique scan? Потому, что в where задан диапазон - меньше либо равно. При этом не важно, уникальный индекс или нет. При сканировании придется проходить листы/значения меньше числа 130 включительно.
````
select * from employees t where t.employee_id <= 130;
````

Пример 3. Oracle начинает чтение с конца индекса и считывает последнее (наивысшее) значение
````
select max(empno) from emp;
````


### Index skip scan
Особенности: Может возникнуть при использовании в составных индексах, когда не задан лидирующий столбец.

Условия:
  1. Есть составной индекс (col1, col2)
  2. В условии where мы указываем только col2. Не указывая ведущий столбец col1.
  3. Если лидирующий столбец имеет большое количество уникальных значений, скорее всего, index skip scan выбран не будет.
  4. Или же лидирующий столбец содержит мало различных значений. А второй столбец содержит много различных значений
Как работает:
  1. Для лидирующего столбца сначала ищем все уникальные значения. count(distinct col1)
  2. Дальше для каждого уникального значения выполняется range scan с учетом значения заданных столбцов.
     сol1 = 1 and col2 = 99
     col1 = 2 and col2 = 99
     col3 = 3 and col2 = 99 

Пример:
````
create index emp_name_ix on employees (last_name, first_name);
select * from employees t where t.first_name = 'Mark';
````

В предикатах не задан лидирующий столбец (“last_name”) индекса.

Уникальных значений 102. select count(distinct t.last_name) from employees t;

Будет построено 102 условных поисковых дерева и по каждому будет совершен поиск:
````
where (last_name = ‘i-ое last_name’ and first_name = ‘Mark’).
where (last_name = ‘i-ое last_name’ and first_name = ‘Mark’).
where (last_name = ‘i-ое last_name’ and first_name = ‘Mark’).
````


### Index Unique Scan
Особенности: Самый быстрый вид индексного доступа.

Условия: 
  1. Существует уникальный индекс.
  2. Все поля индекса задействованы в запросе (where …).

Как работает:
  1. Сканирование начинается с корневого блока и перемещается по ветвям вниз к листовоему блоку, где находится уникальное значение. 
  2. Получаем из листа rowid
  3. Обращаемся к таблице и ищем по rowid строку. 


Пример. На поле employee_id навешен PK. Соответственно, за кадром, создан уникальный индекс. Который используется в этом запросе. Поскольку у нас равенство строгое, значит искомый элемент один. Вот и получается Index Unique Scan.: 
````
select * from employees t where t.employee_id = 100;
````



### Соединения индексов
Описание: Если все нужные данные есть в нескольких индексах, то можно просканировать только эти несколько индексов, не обращаясь к самой таблице.

Условия:
  1. В запросе участвуют только поля, которые есть в индексах.

Пример выполнения:
````
select a, b, c
  from t
 where a = :a
   and b = :b;
````

  - Предположим, что есть индекс для Т(А) и индекс для Т(В,С).
  - Оптимизатор может провести сканирование индекса Т(А), затем индекса Т(В,С). 
  - После чего взять промежуточные результаты и соединить их вместе по ROWID.

