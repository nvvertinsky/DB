### Nested loops
Описание: 
  - Допустим два набора данных.
  - Берем первую строку из первого набора данных. Проходимся по всему второму набору данных. 
  - Если строки совпали, выводим.
  - Сложнось алгоритма: O(N2).

Когда применяется:
  - Если наборы данных содержат мало строк. 
  - Либо наборы содержат много строк, но режим оптимизатора FIRST_ROWS

Как работает:
````
  select empno,
         dname
    from emp,
         dept
   where emp.deptno = dept.deptno;
````

Псевдокод логики процесса соединения:
````
  for x in (select * from emp)
  loop
    index lookup the rowid for x.deptno;
    select * from dept where dept.rowid = that rowid;
    output joined record
  end loop;
````

  1. Читаем первый блок таблицы emp.
  2. Берем первую строку из блока и используем ее значение deptno для поиска в таблице dept
  3. Читаем индексные блоки таблицы dept. Находим нужный лист с rowid строки в dept
  4. Читаем блок и строку по rowid в таблице dept.
  5. Таким образом, за четыре операций логического ввода/вывода можно получить данные.


### Merge join. Соединение сортировкой-слиянием
Описание: 
  - Соединение сортировкой-слиянием будет проводить сортировку первого набора данных, затем сортировку второго набора данных. И после этого будет выполнено слияние результатов.
  - Соединение сортировкой-слиянием является менее эффективным, чем соединение хешированием из-за того, что ОБА набора данных необходимо подвергнуть сканированию и сортировке. При соединении хешированием предварительной обработке подтвергается только один набор данных.
  - Является весьма полезным при операциях объединения по неэквивалетности. Т.е. когда условием соединения является сравнение с диапазоном. (<, >, <=, =>).
  - Сложность алгоритма: O(N*log(N))

Когда применяется:
  - Когда нужно соеденить большой набор данных и отсортировать его.


Пример работы:
````
select a.ename,
       b.ename,
       a.hiredate,
       b.hiredate
  from emp a,
       emp b
 where a.empno = b.empno
   and a.hiredate <= b.hiredate;
````
  1. Читается "EMP a" и сортируется по empno. 
  2. Читается "EMP b" и сортируется по empno. 
  3. Далее применяется соединение сортировкой-слиянием с использованием условия a.hiredate <= b.hiredate

````   
1  1
3  1
4  2
6  2
   3
   5
````	 
  
  4. Сначала сравнивает первые строки двух наборов данных.
  5. Затем сравнение идет дальше во втором наборе данных, пока значение равно значению первого набора.
  6. Если значение из второго набора данных НЕ РАВНО значению из первого набора данных, то переходим на следующую строку в том наборе данных, где значение ниже. Например "1" из первого набора != "2" из второго набора. Смотрим какое значение ниже. Это "1" из первого набора. Значит переходим на следующую строку в первом наборе.



### Hash join
Описание:
  - Является способом объединения двух больших наборов данных или большого набора данных с маленьким. 
  - Сложность алгоритма: O(N)

Особенности:
  - Хеш функция возвращает номер слота для каждого ключа. 
  - Хеш функция может возвращать одно и тоже значение для разных ключей. Это хеш колизия. В этом случае Oracle помещает эти ключи в один и тот же слот 
  - В отличии от merge join требует в условии =

Пример работы:
````
  select t1.object_name,
	 t2.object_name
    from t t1,
	 t t2
   where t1.object_id = t2.object_id
     and t1.owner = 'WMSYS';
````
  - Oracle возьмет самую маленькую из двух таблиц (в примере это будут результаты t1.owner = 'WMSYS', после полного сканирования таблицы) и создаст хеш-таблицу с этими результатами в PGA
  - Если таблица помещается в оперативную память, то Oracle поместит ее в оперативную память.
  - Ключ соединения OBJECT_ID так же будет хеширован и будет использоваться как индекс в хеш-таблице
  - Затем производится сканирование большой таблицы.
  - Для каждой строки большой таблицы Oracle хеширует OBJECT_ID и находит в хеш-таблице соответствующие строки.
  - Если соответствующие строки нашлись, то выводим их


ps. 
Если хеш-таблица не умещается в памяти, то Oracle будет использовать пространство TEMP.
  - При переполнении области хеширования, Oracle находит самый большой раздел в хеш-таблице и записывает его в     TEMP.
  - Часть хеш-таблицы находится в памяти, а часть на диске.
  - Затем Oracle начинает сканировать другую таблицу. 
  - Все так же будет хешироваться ключ-значение из другой таблице.
  - Если хэшированное значение указывает на строку памяти, соединение является законченным.Строка возвращается.
  - Если хэшированное значение указывает на диске, Oracle сохранит эту строку в TEMP.
  - Затем Oracle проведет поочередную обработку каждого временного раздела на диске, считает их в память и     соеденит.
  - Затем выдаст окончательный ответ.
  
  
### Hash join (outer). Внешнее соединение хешированием.
Пример работы:
````
  select ename,
		 dname
    from emp,
		 dept
   where emp.deptno(+) = dept.deptno;
````

  1. Таблица dept сканируется и хешируется.
  2. Таблица emp сканируется для каждой строки.
  3. Хеш-таблица dept исследуется на предмет соответствий. 
    - Если соответствие находится, строка помещается в выходные данные.
	- Запись в хеш-таблице помечается как соответствующая строке.
  4. После того как закончится сканирование emp таблицы, хеш-таблица dept обрабатывается сначала, и любые не помеченные как соответствующие строки выводятся со значением null в столбцах emp.
  
### Внешнее соединения вложенным циклом. nested loops (outer)
Пример работы:
````
  select empno,
         dname
    from emp,
         dept
   where emp.deptno(+) = dept.deptno;
````

В отличии от примера с nested loops, ведущей таблицей стала dept

Псевдокод:
````
  for x in (select * from dept)
  loop
    found_record = false;
	
	for y in (select * from emp where emp.deptno = x.deptno)
	loop
	  found_record = true;
	  output joined record;
	end loop;
    
	if not found_record then
	  output a record with null values for emp columns;
	end if;
  end loop;
````

  1. Читаем первый блок таблицы dept.
  2. Берем первую строку из блока и используем ее значение deptno для поиска в таблице emp
  3. Читаем индексные блоки таблицы emp. Находим нужный лист с rowid строки в dept. Если ничего не нашли, то выводим строки из emp с null значениями
  4. Читаем блок и строку по rowid в таблице dept.
