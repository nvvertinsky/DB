### Index Fast Full Scan
Особенности:
Значительно отличается от полного сканирования индекса. см. ниже.

Условия:
 1. В запросе участвуют только индексированные столбцы (они указаны в select). И вместо полного сканирования индекса можно провести быстрое полное сканирование индекса.
 2. Сортировка данных не важна


Как работает:
  - Читает каждый блок в индексе, включая все ответвляющиеся блоки.
  - Производит чтение множества блоков за одну операцию I/O. По сути параллельно несколько блоков читает. За счет     чего достигается высокая скорость.
  - Не извлекает данные в отсортированном порядке.

Пример:
select empno, empname from emp;


В Full Index Scan полное считывание происходит в упорядоченном виде, поэтому просто так взять и всё считать не получится. Грубо говоря, процессу чтения приходится “прыгать” из блока в блок, которые могут быть в разных файлах или разных частях одного и того же файла, чтобы сохранить упорядоченность.


### Index Full Scan
Особенности:
Читаются все листовые блоки индекса за одну операцию I/O.

Условия:
Фактически, замена full table scan в некоторых ситуациях:
  1. Данных в индексе достаточно для получения результата
  2. Есть шаг с доп. сортировкой в операциях типа order by, group by, join
  3. Порядок использования колонок в order by должен совпадать с порядком колонок в индексе
  4. Порядок использования колонок в group by может не совпадать с порядком в индексе

Как работает:
Сканирование начинается с корневого блока и перемещается по ветвям вниз к самому первому листовому блоку. 
После прочтения первого листового блока все остальные блоки читаются по порядку.
Читается один блок за одну операцию I/O. Это одно из отличий от index fast full scan.

Данные извлекаются все в сортированном виде, это помогает исключать дополнительный этап сортировки в таких операциях как merge join таблиц, обычная сортировка (order by), группировки (group by).

Merge join перед соединением двух таблиц должен отсортировать множества. Группировка - так же требует сортировки множества.

Пример:
select empno, ename from emp order by empno;


### Index Range scan


Особенности: Индексное сканирование по диапазону. Очень часто используемый вид сканирования. Применяется при поиске по диапазону значений или при равенстве из неуникальных индексов.
Поиски типа:
where col1 between или where col1 > … 
или
where col2 = ...

Условия:
  1. В условиях запроса используется один или несколько лидирующих столбцов индекса.
  2. Индекс может быть уникальным или обычным.

Как работает:
Поиск в индексе происходит от узла в котором находится стартовое значение диапазона (берется из запроса). Затем происходит сканирование всех значений после этого стартового значения, в соответствии с условием. Если надо, алгоритм переходит с листа на лист, не поднимаясь к узлу. Помните, что листы связаны между собой как двусвязный список. Поэтому возможны любые направления прохода по индексу asc/desc.(например если в запросе order by desc, то проход по листьям будет в обратном направлении)
Данные извлекаются в сортированном порядке. Это исключает доп сортировку при операциях group by/order by по ключу.

Пример 1.
create index emp_department_ix on employees (department_id);

select * from employees t where t.department_id = 10;

Будет range scan. Казалось бы, почему тут не unique scan? Потому что индекс emp_department_ix не уникальный. И в листах у него не уникальные значения, а значит, добравшись до искомого листа, придется проходить по диапазону равному = 10. Таких элементов будет больше чем “1”. Потому и применяется range scan.

Пример 2. 
select * from employees t where t.employee_id <= 130;

В плане фигурирует range scan по unique index - emp_emp_id_pk. Казалось бы, индекс уникальный, почему не unique scan? Потому, что в where задан диапазон - меньше либо равно. При этом не важно, уникальный индекс или нет. При сканировании придется проходить листы/значения меньше числа 130 включительно.

Пример 3.
select max(empno) from emp;
Oracle начинает чтение с конца индекса и считывает последнее (наивысшее) значение


### Index skip scan
Особенности: Может возникнуть при использовании в составных индексах, когда не задан лидирующий столбец.

Условия:
  1. Есть составной индекс (col1, col2)
  2. В условии where мы указываем только col2. Не указывая ведущий столбец col1.

Как работает:
  1. Для лидирующего столбца сначала ищем все уникальные значения. count(distinct col1)
  2. Дальше для каждого уникального значения выполняется range scan с учетом значения заданных столбцов.
     сol1 = 1 and col2 = 99
     col1 = 2 and col2 = 99
     col3 = 3 and col2 = 99 

Пример:
create index emp_name_ix on employees (last_name, first_name);
 
select * from employees t where t.first_name = 'Mark';

В предикатах не задан лидирующий столбец (“last_name”) индекса.

Уникальных значений 102. select count(distinct t.last_name) from employees t;

Будет построено 102 условных поисковых дерева и по каждому будет совершен поиск:
where (last_name = ‘i-ое last_name’ and first_name = ‘Mark’).
where (last_name = ‘i-ое last_name’ and first_name = ‘Mark’).
where (last_name = ‘i-ое last_name’ and first_name = ‘Mark’).
...

Если лидирующий столбец имеет большое количество уникальных значений, скорее всего, index skip scan выбран не будет.
Но тут надо понимать, что лидирующим столбцом в B-tree индексах, лучше использовать столбец, как раз таки, с большим разнообразием значений.

Наличие skip scan - это повод для оптимизации.


### Index Unique Scan
Особенности: Самый быстрый вид индексного доступа.

Условия: 
  1. Существует уникальный индекс.
  2. Все поля индекса задействованы в запросе (where …).

Как работает:
Суть доступа, в том, что искомый элемент один, т.к. индекс уникальный. Поэтому достаточно, по ключу, пройти до нужного листа. Получить из листа одну пару ключ-rowid. Дальше по rowid получить строку из таблицы.

Инфа от Кайта: В уникальном индексе Oracle не добавляет ROWID к индексному ключу.
Как тогда ищется строка в таблице? Ведь ROWID нет. А значит мы не знаем что это за строка в таблице.

Пример: select * from employees t where t.employee_id = 100;
На поле employee_id навешен PK. Соответственно, за кадром, создан уникальный индекс. Который используется в этом запросе. Поскольку у нас равенство строгое, значит искомый элемент один. Вот и получается Index Unique Scan.


### Соединения индексов

Описание:
Если все нужные данные есть в нескольких индексах, то можно просканировать только эти несколько индексов, не 
обращаясь к самой таблице.

Условия: 
  1. В запросе участвуют только поля, которые есть в индексах.

Пример выполнения:

select a, b, c
  from t
 where a = :a
   and b = :b;

Допустим существуют индексы для полей A, B, C. Это могут быть как составные индексы, так и индексы по отдельным столбцам. Предположим, что есть индекс для Т(А) и индекс для Т(В,С).
Оптимизатор может провести сканирование индекса Т(А), затем индекса Т(В,С). 
После чего взять промежуточные результаты и соединить их вместе по ROWID.

