### По физической организации: 
  1. B-Дерево. Сбалансированное дерево.
  2. Bitmap. Битовая карта.

### По типу: 
  1. Уникальный
  2. Обычные индексы
  3. Функциональные индексы
  
  4. Индексы с обратной сортировкой
    Описание:
	  - Хранит значения в порядке убывания. Проще говоря в листовых блоках слева будет самое большое значение, а справа самое маленькое.
	  
	Зачем нужен: 
	  - Когда есть запрос сортирует столбцы по убыванию (desc). Позволяет избежать доп. сортировки при выполнении.
	
	Пример: 
	  - Пользователь запрашивает hr.employees фамилии в порядке возростания (от А до Я) и ID отделов в порядке убывания (от высокого до низкого), то БД может использовать индекс ниже и избежать доп. сортировки.
	  
	Команда: 
	````
	  create index emp_name_dpt_ix on hr.employees(last_name asc, department_id desc);
	````
	
  5. Локальные и глобальные индексы
  
  6. Реверсивный
    Описание: 
	  - Это индекс, который хранит значения столбцов таблицы в обратном порядке
	
	Зачем нужен: 
	  - Чтобы уменьшить конкуренцию за крайний правый листовой блок индеса. Он же горячий блок.
	  
	Пример: 
	  - В обычном индексе по PK данные пишутся в крайний правый листовой блок. Он же горячий блок. 
	  - Это увеличивает конкуренцию за этот блок. 
	  - Как результат данные добавляются медленее.
	 
	Команда: 
	````
	  create index t1_idx on t1 (id) reverse;
	````
	
 
 
### B-Дерево.
Описание: Сбалансированное потому что, до листового блока всегда одинаковый уровень отвлетвляющихся блоков. 

Структура: 
  - Листовые узлы (leaf blocks) - Самый нижний уровень блоков дерева. Которые содержат индексный ключ и ROWID.
  - Ответвляющиеся блоки - блоки над листовыми узлами.
  
Как работает: 
  1. Нам нужно найти значение 11.
  2. Поиск начинается с верхней части дерева.
  3. 11 входит в 0..40, значит переходим в самый левый блок.
  4. 11 входит в 11..19, значит переходит в правый листовой узел.
  5. Находим значение 11 и берем ROWID. Чтобы в дальше найти строку в таблице.

Когда B-дерево индексы использовать:
  - Для индексации столбцов, только если вы собираетесь получать доступ через индекс к небольшому % строк таблицы. (от 1% до 5% от общего объема)
    - Например вы читаете индекс, чтобы получить строку таблицы. Здесь вас необходим доступ к очень небольшому % строк в таблице.
  - Так же если вы планируете обрабатывать много строк таблицы, и индекс может использоваться вместо таблицы.
    - Например индекс содержит достаточно информации чтобы ответить на целый запрос. При этом обращаться к таблице вообще не нужно.
  
В каком порядке указывать столбцы: 
  - Лидирующим столбцом в B-tree индексах, лучше использовать столбец, как раз таки, с большим разнообразием значений. То есть самые селективные.
	


### Bitmap
Описание: 	
  - В этом индексе БД хранит битовую карту для каждого значения.
  - Каждое значения ключа указывает на несколько строк. 
  - Это индекс, хорошо работающий со столбцами, которые содержат мало уникальных значений.

Особенности: 
  - Из документации Oracle. Битовые индексы в первую очередь предназначены для хранилищ данных.
  - Если индексированный столбец обновляется, то БД блокирует запись с ключем VALUE_1. 
  - А так как ключ указывает на несколько строк, то все эти строки блокируются.
  - Поэтому bitmap не подходят для OLTP.

Где используются:
  - Для стобцов, которые содержат мало уникальных значений.
  - Таблица либо доступна только на чтение либо над ней совершается редко DML операции.
  
Как это работает:
  1. Value;Row1;Row2;Row3;Row4;Row5
  2. M;1;0;1;1;0
  3. F,0;1;0;0;1
  
  - Есть значения ключа M или F. 
  - Строим битовую карту, где указываем 1 - есть значение в строке, 0 - нет значения в строке.
  - Функция сопоставления преобразует каждый бит (1,0) в rowid.
  - Если 2 и больше битовых индексов и в запросе участвуют все проиндексированные столбцы, то Oracle объединяет эти индексы.

Пример: 
  - Самый типичный пример, который приведен в документации - это колонка пол человека.
  - Два значения: Мужской и Женский.

Плюсы: 
  - Меньше весят. Для хранилищ это хорошо.
  - Хорошо работают с низкоселективными столбцами.
  - Хранят null и ссылки на эти строки.
 
Минусы: 
  - Плохо ведут себя в OLTP системах. Потому что одна запись битового индекса указывает на множество строк. И если сеанс модифицирует проиндексированные данные, то все строки на которые указывает запись индекса блокируется. Блокируется не каждая строка, но многие из них. Это уменьшает параллельный доступ.

Где часто используются: 
  - В хранилищах данных. То есть там где редко выполняются DML операции. 



### Какой индекс когда эффективнее
  - Сканирование обычного B-tree индекса эффективно, когда нужно выбрать 1 или несколько строк. Но максимальное кол-во строк должно быть маленьким.

  - Битовый индекс хорош тогда когда обычный b-tree уже не справляется с кол-вом строк. То есть битовый индекс может работать с бОльшим кол-вом строк чем обычный b-tree индекс.

  - Но если очень много, то скорее всего быстрее уже будет полное сканирование таблицы.
  
  

### Почему не используется индекс: 
  1. Условие в запросе не используется головную часть индекса index(x,y). Только если головная часть содержит большое кол во отличающихся значений. А если кол во отличающихся значение мало, то будет index skip scan
  ````
  select * from t where y = 1. 
  `````


  2. Когда выполняем запрос подсчета всех строке. Вместо поиска по индексу мы выполняем full scan table. Возможно индекс построен на наборе столбцов, которые могут принимать значения null
  ````
  select count(*) from t. 
  ````
  
  3. Используется функция по столбцу. Но индекс не основан на функции.
  ````
  select * from t where trunc(date_col) = trunc(sysdate);
  ````
  Можно переписать условие на 
  ````
  where date_col >= trunc(sysdate)
    and date_col <= trunc(sysdate + 1)
  ````
  По возможности вы должны всегда убирать функции от столбцов базы данных, когда они находятся в предикате.


  4. Мы проиндексировали столбец varchar2, в нем содержаться только числовые данные. И затем делаем запрос 
  ````
  select * from t where indexed_column = 5. 
  ````
  Oracle переписывает запрос на:
  ````
  select * from t where to_number(indexed_column) = 5
  ````

  5. Выборка большого кол-ва строк.
  ````
  select count(*) from t where x < 50; -- индекс используется
  select count(*) from t where x < 1000000; -- индекс не используется
  ````

  6. Мы не обновляли статистику для таблиц. Таблицы обычны были малы, но теперь значительно выросли.

  7. Каждое ограничение уникальности должно иметь хотя бы один столбец not null. Только тогда можно использовать индекс в запросе.