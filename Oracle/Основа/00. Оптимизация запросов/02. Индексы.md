### По физической организации: 
  1. B-Дерево. Сбалансированное дерево.
  2. Bitmap
  3. Кластерные индексы

### По типу: 
  1. Уникальные
  2. Обычные индексы по полям
  3. Функциональные индексы
  4. Индексы с сортировкой
  5. Локальные и глобальные индексы
  6. Реверсивный
    Описание: 
	  - Это индекс, который хранит значения столбцов таблицы в обратном порядке
	
	Зачем нужен: 
	  - Чтобы уменьшить конкуренцию за крайний правый листовой блок индеса. Он же горячий блок.
	  
	Пример: 
	  - В обычном индексе по PK данные пишутся в крайний правый листовой блок. Он же горячий блок. 
	  - Это увеличивает конкуренцию за этот блок. 
	  - Как результат данные добавляются медленее.
	 
	Команда: 
	  - create index t1_idx on t1 (id) reverse;
	
 
 
### B-Дерево.
Описание: Сбалансированное потому что, до листового блока всегда одинаковый уровень отвлетвляющихся блоков. 

Структура: 
  - Листовые узлы (leaf blocks) - Самый нижний уровень блоков дерева. Которые содержат индексный ключ и ROWID.
  - Ответвляющиеся блоки - блоки над листовыми узлами.
  
Как работает: 
  1. Нам нужно найти значение 11.
  2. Поиск начинается с верхней части дерева.
  3. 11 входит в 0..40, значит переходим в самый левый блок.
  4. 11 входит в 11..19, значит переходит в правый листовой узел.
  5. Находим значение 11 и берем ROWID. Чтобы в дальше найти строку в таблице.

Когда B-дерево индексы использовать:
  - Для индексации столбцов, только если вы собираетесь получать доступ через индекс к небольшому % строк таблицы. (от 1% до 5% от общего объема)
    - Например вы читаете индекс, чтобы получить строку таблицы. Здесь вас необходим доступ к очень небольшому % строк в таблице.
  - Так же если вы планируете обрабатывать много строк таблицы, и индекс может использоваться вместо таблицы.
    - Например индекс содержит достаточно информации чтобы ответить на целый запрос. При этом обращаться к таблице вообще не нужно.
  - Лидирующим столбцом в B-tree индексах, лучше использовать столбец, как раз таки, с большим разнообразием значений.
	


### Bitmap
Как работает:
  - Прежде чем из листьев индекса обратится к блокам таблицы, строится битовая карта. В битовой карте уже обозначено в какой блок таблицы нужно сходить

Зачем нужно: 
  - Это решает проблему чтения одного и того же блока таблицы несколько раз.
  - На изображении "Обычный индекс" видно, что в процессе сканирования индекса по диапозону, мы можем несколько раз обращаться к одному и тому же блоку.
  - На изображении "Битовый индекс" видно, что с помощью постоения битовой карты, эта проблема решается. Мы считываем несколько значений из блока таблицы за один раз.

Использование памяти:
  - Для построения битовой карты нужна оперативная память
  - Если память закончилась, происходит огрубление части уже построенной карты до отдельный страниц. То есть мы в карте просто помечаем номер блока таблицы в который нужно сходить.
  - При чтении такого блока, берем все значения из него и перепроверяем условие по каждому значению.
 
Минусы: 
  - Плохо ведут себя в OLTP системах. Потому что одна запись битового индекса указывает на множество строк. И если сеанс модифицирует проиндексированные данные, то все строки на которые указывает запись индекса блокируется. Блокируется не каждая строка, но многие из них. Это уменьшает параллелизм. 



### Какой индекс когда эффективнее
  - Сканирование обычного B-tree индекса эффективно, когда нужно выбрать 1 или несколько строк. Но максимальное кол-во строк должно быть маленьким.

  - Битовый индекс хорош тогда когда обычный b-tree уже не справляется с кол-вом строк. То есть битовый индекс может работать с бОльшим кол-вом строк чем обычный b-tree индекс.

  - Но если очень много, то скорее всего быстрее уже будет полное сканирование таблицы.
  
  

### Почему не используется индекс: 
  1. Условие в запросе не используется головную часть индекса index(x,y). Только если головная часть содержит большое кол во отличающихся значений. А если кол во отличающихся значение мало, то будет index skip scan
  ````
  select * from t where y = 1. 
  `````


  2. Когда выполняем запрос подсчета всех строке. Вместо поиска по индексу мы выполняем full scan table. Возможно индекс построен на наборе столбцов, которые могут принимать значения null
  ````
  select count(*) from t. 
  ````
  
  3. Используется функция по столбцу. Но индекс не основан на функции.
  ````
  select * from t where trunc(date_col) = trunc(sysdate);
  ````
  Можно переписать условие на 
  ````
  where date_col >= trunc(sysdate)
    and date_col <= trunc(sysdate + 1)
  ````
  По возможности вы должны всегда убирать функции от столбцов базы данных, когда они находятся в предикате.


  4. Мы проиндексировали столбец varchar2, в нем содержаться только числовые данные. И затем делаем запрос 
  ````
  select * from t where indexed_column = 5. 
  ````
  Oracle переписывает запрос на:
  ````
  select * from t where to_number(indexed_column) = 5
  ````

  5. Выборка большого кол-ва строк.
  ````
  select count(*) from t where x < 50; -- индекс используется
  select count(*) from t where x < 1000000; -- индекс не используется
  ````

  6. Мы не обновляли статистику для таблиц. Таблицы обычны были малы, но теперь значительно выросли.

  7. Каждое ограничение уникальности должно иметь хотя бы один столбец not null. Только тогда можно использовать индекс в запросе.