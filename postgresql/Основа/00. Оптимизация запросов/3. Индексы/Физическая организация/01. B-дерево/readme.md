# B-Дерево.

### Описание: 
  - Сбалансированное потому что, до листового блока всегда одинаковый уровень отвлетвляющихся блоков. 

### Структура: 
  - Листовые узлы (leaf blocks) - Самый нижний уровень блоков дерева. Которые содержат индексный ключ и ROWID.
  - Ответвляющиеся блоки - блоки над листовыми узлами.
  
### Как работает: 
  1. Нам нужно найти значение 11.
  2. Поиск начинается с верхней части дерева.
  3. 11 входит в 0..40, значит переходим в самый левый блок.
  4. 11 входит в 11..19, значит переходит в правый листовой узел.
  5. Находим значение 11 и берем ROWID. Чтобы в дальше найти строку в таблице.

### Когда B-дерево индексы использовать:
  - Для индексации столбцов, только если вы собираетесь получать доступ через индекс к небольшому % строк таблицы. (от 1% до 5% от общего объема)
    - Например вы читаете индекс, чтобы получить строку таблицы. Здесь вас необходим доступ к очень небольшому % строк в таблице.
  - Еще можно сделать fast full scan индекса вместо full scan таблицы. Будет быстрее за счет распараллеливания.
  
### В каком порядке указывать столбцы: 
  - Лидирующим столбцом в B-tree индексах, лучше использовать столбец, как раз таки, с большим разнообразием значений. То есть самые селективные.
  
### По типу: 
  - Обычные индексы на одно или несколько полей
  - Функциональные индексы
  - Частичные индексы
  - Уникальный
  - Индексы с обратной сортировкой
    - Описание: Хранит значения в порядке убывания. Проще говоря в листовых блоках слева будет самое большое значение, а справа самое маленькое.
	- Зачем нужен: Например когда нам нужны данные таблицы в обратной сортировке. Просто делает index full scan и ничего сортировать не надо.
	- Пример: Пользователь запрашивает hr.employees фамилии в порядке возростания (от А до Я) и ID отделов в порядке убывания (от высокого до низкого), то БД может использовать индекс ниже и избежать доп. сортировки.
	- Команда create index emp_name_dpt_ix on hr.employees(last_name asc, department_id desc);